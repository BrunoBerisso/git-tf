#!/bin/bash

if [ -z "$( which git )" ]; then
  echo 'Git not found in $PATH'
fi
tf=$( git config tf.cmd )
if [ -z "$tf" ]; then
  tf=tf
fi


readConfig() {
  readValue() {
    eval $1=$( git config tf.$1 )
    if [ -z "${!1}" ]; then
      echo git tf is not configured. Config value "tf.$1" not found.
      exit 2
    fi
  }
  readValue domain
  readValue DOMAIN
  readValue username
}

exitCode=0
verbose=true
noChecks=
exec=
tmpDir=/tmp/git-tf
# main commands
number=9999999

usage() {
  echo "Usage is not written yet. Sorry."
}

push() {
  lastCommit=$( git log -n 1 --format=%H tfs )
  unmergedCommits=$( git log $( git log master --format=%H -n 1 ).. master --oneline )
  if [ "$unmergedCommits" ]; then
    exitCode=7
    echo "You have unmerged changes in tfs branch:"
    echo "$unmergedCommits" | indent
    return
  fi

  echo Checking whether there are no unfetched changes on TFS...
  latestGitChangeset=$( git notes show  $lastCommit | grep -Po '^\d+' | tail -n 1 )
  latestTfChangeset=$( $tf history -stopAfter:1 -recursive . | grep -oP '^\d+' )
  if [ $latestGitChangeset -lt $latestTfChangeset ]; then
    echo "There are unfetched changes on TFS. Fetch and merge them before pushing".
    echo Latest local changeset: $latestGitChangeset
    echo Latest TFS changeset: $latestTfChangeset
    return
  fi

  echo Pushing commits
  echo Last synchronized commit: $( git log -n 1 --format=%h tfs )
  commitNumber=$( min $number $( git log --oneline $lastCommit.. master | wc -l ) )
  if [ $commitNumber -eq 0 ]; then
    echo Nothing to push
    return
  fi
  echo $commitNumber commit\(s\) to be pushed:
  git log $lastCommit.. --format=%H master | tac | while read hash; do
    echo
    expect0 git checkout $hash
    echo Pushing \"$( git log -n 1 --oneline )\" to TFS:
    echo $( git log -n 1 --format=%s%n%b ) > $tmpDir/comment

    if [ -n "$( readChanges TUX )" ]; then
      git diff
      echo "Unexpected file change!!"
      echo
      git diff --raw --find-copies-harder HEAD^.. --diff-filter=TUX
      exit 1
    fi

    readChanges() {
      git diff --raw --find-copies-harder HEAD^.. --diff-filter=$1 \
        | sed 's/^:\w\+\s\w\+\s\w\+\.\+\s\w\+\.\+\s\w\+\t//'
    }

    files=$( readChanges D )
    if [ -n "$files" ]; then
      echo Removed:
      echo "$files" | indent
      expect0 $tf rm $files -recursive
    fi

    files=$( readChanges M )
    if [ "$files" ]; then
      echo Modified:
      echo "$files" | indent
      expect0 $tf checkout $files
    fi

    renames=$( readChanges R )
    if [ "$renames" ]; then
      echo Renamed:
      echo "$renames" | while read -r file; do
        echo $file | indent
        expect0 $tf rename $file
      done
    fi

    files=$( readChanges CA | sed 's/^[^\t]\+\t//' )
    if [ -n "$files" ]; then
      echo Added:
      echo "$files" | indent
      expect0 $tf add $files
    fi

    echo Checking in...
    lastInLine=""
    while read -r inLine; do
      lastInLine="$inLine"
      echo $inLine | indent
    done < <( $tf checkin -comment:@$tmpDir/comment -recursive . )
    if [ ${?} -ne 0 ]; then exit 1; fi

    echo Moving TFS head and marking the commit with a note
    expect0 git checkout tfs
    expect0 git merge --ff-only $hash

    # add a note about the changeset number
    changeSetNumber=$( echo $lastInLine  | sed 's/Changeset \#\([0-9]\+\) checked in./\1/' )
    if [ -z $changeSetNumber ]; then
      echo Could not detect the changeset number!
      echo Last checkin output line: $lastInLine
      exitCode=1
      return
    fi

    echo -n $changeSetNumber "$( seq -s " " $( expr 10 - length $changeSetNumber ) | sed 's/[0-9]//g' )" $DOMAIN\\$username \
      $( date "+%b %d, %Y %r" ) "" > $tmpDir/changeset
    cat $tmpDir/comment >> $tmpDir/changeset
    expect0 git notes add -F $tmpDir/changeset $hash

    decNumber
    if [ $number -eq 0 ]; then break; fi
  done
}

fetch () {
  echo Fetching from TFS
  lastCommit=$( git log -n 1 --format=%H tfs )
  lastChangeset=$( git notes show  $lastCommit | grep -Po '^\d+' | tail -n 1 )
  echo Last synchronized changeset: $lastChangeset

  latestCommit=$( $tf history -stopAfter:1 -recursive . | grep -oP '^\d+' )
  echo Latest changeset on TFS: $latestCommit
  if [ $lastChangeset -eq $latestCommit ]; then
    echo Nothing to fetch
    return
  fi

  tfHistoryCmd="$tf history -recursive -version:C$lastChangeset~C$latestCommit ."
  echo $tfHistoryCmd
  tfHistory=$( $tfHistoryCmd | tac | grep -P '^\d+\s{2,}\w+' )
  echo $( expr $( echo "$tfHistory" | wc -l ) - 1 ) changeset\(s\) to fetch


  echo Making files read-only
  find -type f -exec chmod -w {} \;
  expect0 chmod -R +w .git

  while read -r line; do
    changeset=$( echo $line | grep -Po '^\d+' )
    if [ -z $changeset -o $changeset -le $lastChangeset ]; then continue; fi

    echo
    echo Fetching \"$line\"...

    comment=$tmpDir/comment
    echo $line | grep -Po '(?<=\d:\d\d:\d\d [AP]M ).+$' > $comment
    if [ ! -s $comment ]; then
      if [ $( echo $line | grep -Pc '\d+:\d+:\d+ [AP]M ?$' ) -eq 0 ]; then
        echo "Could not parse comment!"
        echo $line
        echo Here is entire history:
        echo "$tfHistory"
        exit 1
      fi
      echo Comment is empty, so using the entire line as a commit comment
      echo "$line" > $comment
    fi

    expect0 $tf get -version:$changeset -recursive . | indent

    echo Committing to Git...
    author=$( echo $line | grep -Po '(?<=COMPONENTONE\\)[^\s]+' )
    expect0 git add .
    expect0 git commit -F $comment "--author=\"$author <$author@$domain>\"" | indent

    # adding a note
    echo "$line" > $tmpDir/note
    git notes add -F $tmpDir/note $( git log -n 1 --format=%H )

    decNumber
    if [ $number -eq 0 ]; then break; fi
  done < <( echo "$tfHistory" )

  echo Making files writable
  find -type f -exec chmod +w {} \;
}

pull () {
  fetch
  echo Rebasing
  git checkout master | indent
  git rebase tfs  | indent
}

init() {
  root=$( git rev-parse --show-toplevel 2>&1 )
  if [ ${?} -ne 0 ]; then
    git status
    exitCode=123
    return
  fi

  pushd "$root" > /dev/null
  readConfig

  if [ "$( git status -s )" ]; then
    echo "Worktree is dirty"
    exitCode=6
    return
  fi

  if [ -z $noChecks ]; then

    echo Checking TFS status. There must be no pending changes...
    workfold=$( $tf workfold . )
    if [ $( echo "$workfold" | grep -Pc ": $PWD$" ) -ne 1 ]; then
      echo TF mapped folder does not match git root work folder!
      echo Expected: $PWD
      echo Actual: $( echo "$workfold" | tail -n +4 | grep -Po ': .+$' )
      exitCode=5
      return
    fi
    if [ "$( $tf status )" != "There are no matching pending changes." ]; then
      echo "TFS status is dirty!"
      exit 1
    fi
  fi

  status=$( git status -sb )
  lineN=$( echo $status | wc -l )
  if [ $lineN -ne 1 ]; then
    echo "Worktree is dirty!"
    exit 1
  fi
  origBranch=$( echo $status | sed 's/##\s\(\w\+\)/\1/' )
  if [ "$origBranch" = "HEAD (no branch)" ]; then
    echo Not currently on any branch
    exit 1
  fi
  expect0 git checkout tfs
  mkdir -p $tmpDir
}
readOptions() {
  lastOption=""
  for o in $@; do
    if [ "${o:0:2}" = "--" ]; then
      lastOption=${o:2}
      debug "option found: $lastOption"
      eval $lastOption=true
    elif [ ! -z $lastOption ]; then
      debug "option $lastOption=$o"
      eval $lastOption=$o
      lastOption=""
    fi
  done
}
main() {
  case $1 in
    push)
      push
      ;;
    fetch)
      fetch
      ;;
    pull)
      pull
      ;;
    hello)
      echo Hello. I\'m git-tfs.
      ;;
    *)
      usage
      ;;
  esac
}
finalize() {
  popd > /dev/null
  rm -rf $tmpDir
  expect0 git checkout $origBranch
}

## Utils

expect0() {
  out=$( eval "$@ 2>&1" )
  if [ ${?} -ne 0 ]; then
    echo "$out"
    exit ${?}
  fi
}


debug() {
  if [ $verbose = true ]; then
    args=$@
    for (( i=1; i<=$#; i++ )); do
      echo ${!i}
    done
  fi
}

decNumber() {
  if [ $number -gt 0 ]; then
    let number--
  fi
}
indent() {
  while read -r line; do
    echo "  $line"
  done
}

min() {
  if [ $1 -le $2 ]; then
    echo $1
  else
    echo $2
  fi
}

if [ -z "$1" -o "$1" == "--help" ]; then
  usage
  exit
fi

readOptions $@
init
if [ $exitCode -eq 0 ]; then
  main $@
fi
finalize
exit $exitCode
