#!/bin/bash

if [ -z "$( which git )" ]; then
  echo 'Git not found in $PATH'
  exit 1
fi
export tf=$( git config tf.cmd )
if [ -z "$tf" ]; then
  tf=tf
fi

export GIT_NOTES_REF=refs/notes/tf
export verbose=true
export noChecks=
export debug=
export tmpDir=/tmp/git-tf
export number=9999999

usage() {
  echo "Usage is not written yet. Sorry."
}

init() {
  local root=$( git rev-parse --show-toplevel 2>&1 )
  if [ $? -ne 0 ]; then
    git status
    exit 123
  fi

  readValue() {
	eval export $1=$( git config tf.$1 )
	if [ -z "${!1}" ]; then
	  echo git tf is not configured. Config value "tf.$1" not found.
	  exit 2
	fi
  }
  readValue domain
  readValue winDomain
  readValue username

  pushd "$root" > /dev/null

  if [ "$( git status -s )" ]; then
    echo "Worktree is dirty"
    exit 6
  fi

  if [ -z "$noChecks" ]; then
    echo Checking TFS status. There must be no pending changes...
    local workfold=$( $tf workfold . )
    if [ $? -ne 0 ]; then
      exit 124
    fi
    if [ $( echo "$workfold" | grep -Pc ": $PWD$" ) -ne 1 ]; then
      echo TF mapped folder does not match git root work folder!
      echo Expected: $PWD
      echo Actual: $( echo "$workfold" | tail -n +4 | grep -Po ': .+$' )
      exit 5
    fi
    if [ "$( $tf status )" != "There are no matching pending changes." ]; then
      echo "TFS status is dirty!"
      exit 1
    fi
  fi

  origBranch=$( git status -sb | sed 's/##\s\(\w\+\)/\1/' )
  if [ "$origBranch" = "HEAD (no branch)" ]; then
    echo Not currently on any branch
    exit 1
  fi
  expect0 git checkout tfs
  mkdir -p $tmpDir
}

main() {
  if [ "$command" ]; then
    export gittf=$( readlink -f ${BASH_SOURCE[0]} )
    if [ -a "$gittf-$command" ]; then
      $gittf-$command $@
      return
    fi
  fi

  usage
}
finalize() {
  popd > /dev/null
  rm -rf $tmpDir
  if [ "$origBranch" ]; then
    expect0 git checkout $origBranch
  fi
}

## Utils

expect0() {
  if [ "$debug" ]; then
    echo "$@"
  fi

  out=$( eval "$@ 2>&1" )
  if [ $? -ne 0 ]; then
    echo "$out"
    exit $?
  fi
}


debug() {
  if [ $verbose = true ]; then
    for i; do
      echo $i
    done
  fi
}

decNumber() {
  if [ $number -gt 0 ]; then
    let number--
  fi
}
indent() {
  while read -r line; do
    echo "  $line"
  done
}

min() {
  if [ $1 -le $2 ]; then
    echo $1
  else
    echo $2
  fi
}

export -f expect0 debug decNumber indent min
if [ -z "$1" -o "$1" == "--help" ]; then
  usage
  exit
fi

# read options
args=`getopt vCn "$@"`
if [ $? != 0 ] ; then echo "Terminating..." >&2 ; exit 10 ; fi
set -- $args
while true ; do
  if [ "$1" != "--" -a "$debug" ]; then
    echo "Option found: " $1
  fi
  case "$1" in
    -v|--verbose) verbose=true; shift ;;
    -d|--debug) debug=true; shift ;;
    -C|--noChecks) noChecks=true; shift ;;
    -n|--number) number=$2; shift 2 ;;
    --) shift ; break ;;
    *) echo "Internal error!" ; exit 1 ;;
  esac
done
if [ $# -gt 0 ]; then
  command=$1
  shift
fi

init
main $@
exitCode=$?
finalize
exit $exitCode
